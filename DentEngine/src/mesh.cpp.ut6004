#include "mesh.h"
#include <QDebug>

Mesh::Mesh(){

}

void Mesh::addFace(QVector3D v0, QVector3D v1, QVector3D v2){
    getVertexIdx(v1);
    MeshVertex mv0 = MeshVertex(v0);
    MeshVertex mv1 = MeshVertex(v1);
    MeshVertex mv2 = MeshVertex(v2);
    int vertex_idx = vertices.size();
    mv0.idx = vertex_idx;
    mv1.idx = vertex_idx + 1;
    mv2.idx = vertex_idx + 2;
    vertices.emplace_back(mv0);
    vertices.emplace_back(mv1);
    vertices.emplace_back(mv2);

    MeshFace mf;
    mf.idx = faces.size();
    mf.mesh_vertex[0] = mv0.idx;
    mf.mesh_vertex[1] = mv1.idx;
    mf.mesh_vertex[2] = mv2.idx;

    vertices[mv0.idx].connected_faces.emplace_back(mf.idx);
    vertices[mv1.idx].connected_faces.emplace_back(mf.idx);
    vertices[mv2.idx].connected_faces.emplace_back(mf.idx);
    faces.emplace_back(mf);
}

//const int vertex_meld_distance = int64_t((0.3) * 1000);
const int vertex_meld_distance = 0.03;

int vertexHash(QVector3D v)
{
    qDebug() << v.x() + vertex_meld_distance/2;
    qDebug() << ((v.x() + vertex_meld_distance/2)/vertex_meld_distance);
    qDebug() << (int)((v.y() + vertex_meld_distance/2)/vertex_meld_distance);
    qDebug() << (int)((v.z() + vertex_meld_distance/2)/vertex_meld_distance);
    /*qDebug() << v.x() << v.y() << v.z();
    qDebug() << ((int)((v.x() + vertex_meld_distance/2) / vertex_meld_distance));
    qDebug() << ((int)((v.y() + vertex_meld_distance/2) / vertex_meld_distance));
    qDebug() << ((int)((v.z() + vertex_meld_distance/2) / vertex_meld_distance));
    return ((int)((v.x() + vertex_meld_distance/2) / vertex_meld_distance)) ^\
            (((int)((v.y() + vertex_meld_distance/2) / vertex_meld_distance)) << 10) ^\
            (((int)((v.z() + vertex_meld_distance/2) / vertex_meld_distance)) << 20);*/
}

int Mesh::getVertexIdx(QVector3D v){
    //qDebug() << vertices_hash[vertexHash(v)].idx;
    //vertices_hash[v]
    //qDebug() << vertices_hash.value(v).idx;
    qDebug() << vertices_hash.value(vertexHash(v)).idx << vertexHash(v);
    return 1;
}

// add connected face idx to each meshes
void Mesh::connectFaces(){
    qDebug() << faces.size();
    for (int i=0; i<faces.size(); i++){
        MeshFace mf = faces[i];
        mf.connected_face_idx[0] = findFaceWith2Vertices(mf.mesh_vertex[0], mf.mesh_vertex[1], i); // connected to vertex 0 1
        mf.connected_face_idx[1] = findFaceWith2Vertices(mf.mesh_vertex[1], mf.mesh_vertex[2], i); // connected to vertex 0 1
        mf.connected_face_idx[2] = findFaceWith2Vertices(mf.mesh_vertex[2], mf.mesh_vertex[0], i); // connected to vertex 0 1
    }
}

// find face containing 2 vertices presented as arguments
int Mesh::findFaceWith2Vertices(int v0_idx, int v1_idx, int self_idx){
    std::vector<int> candidates;
    qDebug() << vertices[v0_idx].connected_faces.size();
    for (int f: vertices[v0_idx].connected_faces){
        if (f == self_idx)
            continue;
        qDebug() << v1_idx << faces[f].mesh_vertex[0] << faces[f].mesh_vertex[1] << faces[f].mesh_vertex[2];
        if (faces[f].mesh_vertex[0] == v1_idx || faces[f].mesh_vertex[1] == v1_idx || faces[f].mesh_vertex[2] == v1_idx){
            candidates.emplace_back(f);
        }
    }
    if (candidates.size() == 0){
        qDebug() << "no candidates";
        return -1;
    }
    if (candidates.size() == 1){
        qDebug() << "found face";
        return candidates[0];
    } else {
        qDebug() << candidates.size() << "multiple faces are connected so outputting first connected face" << candidates[0];
        return candidates[0];
    }
}
