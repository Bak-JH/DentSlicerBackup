#include "slicer.h"
using namespace ClipperLib;

Paths subj;
Paths clip;
Paths solution;

// converts float point to int in microns
void Slicer::addPoint(float x, float y, Path *path)
{
    IntPoint ip;
    ip.X = (int) x*cfg->resolution;
    ip.Y = (int) y*cfg->resolution;
    path->push_back(ip);
}

int Slicer::slice(Mesh* mesh){
    if (! strcmp(cfg->slicing_mode, "uniform")){
        float delta = cfg->layer_height;
        vector<float> planes ;
        vector<vector<int>> traingleLists = buildTriangleLists(mesh, planes, delta);
    } else if (cfg->slicing_mode == "adaptive") {
        // adaptive slice
    }
}

// builds vector of vector of triangle idxs sorted by z_min
vector<vector<int>> Slicer::buildTriangleLists(Mesh* mesh, vector<float> planes, float delta){

    // Create List of list
    vector<vector<int>> list_list_triangle;
    for (int l_idx=0; l_idx < planes.size()+1; l_idx ++){
        vector<int>* triangles_per_layer = new vector<int>;
        list_list_triangle.push_back(* triangles_per_layer);
    }

    // Uniform Slicing O(n)
    if (delta>0){
        for (int f_idx=0; f_idx<mesh->faces.size(); f_idx++){
            int llt_idx;
            MeshFace mf = mesh->idx2MF(f_idx);
            float z_min = mesh->getFaceZmin(mf);

            if (z_min < planes[0])
                llt_idx = 0;
            else if (z_min > planes[planes.size()-1])
                llt_idx = planes.size()-1;
            else
                llt_idx = ((z_min - planes[0])/delta) +1;

            list_list_triangle[llt_idx].push_back(f_idx);
        }
    }

    // General Case
    else {

    }

    return list_list_triangle;
}

int Slicer::meshSlice(Mesh* mesh){

}

int Slicer::contourConstruct(){

}

int Slicer::sliceLayer(Mesh* mesh, float z)
{

    Paths subj;

    Path p;
    addPoint(100,100, &p);
    addPoint(200,100, &p);
    addPoint(200,200, &p);
    addPoint(100,200, &p);
    subj.push_back(p);

    Path p2;
    addPoint(150,50, &p2);
    addPoint(175,50, &p2);
    addPoint(175,250, &p2);
    addPoint(150,250, &p2);
    clip.push_back(p2);


    AddPaths(subj, ptSubject, true);
    AddPaths(clip, ptClip, true);
    Execute(ctIntersection, solution, pftNonZero, pftNonZero);

    printf("solution size = %d\n",(int)solution.size());
    for (unsigned i=0; i<solution.size(); i++)
    {
        Path p3 = solution.at(i);

        for (unsigned j=0; j<p3.size(); j++)
        {
            IntPoint ip = p3.at(j);
            printf("%d = %lld, %lld\n",j, ip.X,ip.Y);
        }

    }

    return 0;
}
